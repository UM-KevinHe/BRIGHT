#include <Rcpp.h>
#include <RcppEigen.h>
#include <math.h>
#include<string.h>
//[[Rcpp::depends(RcppEigen)]]

using namespace Rcpp;
using Eigen::MatrixXd;

// all the input must be sorted according to t, large->small.  

// [[Rcpp::export]]
double norm(Eigen::MatrixXd x, int p) {
  double x_norm = 0;
  for (int j=0; j<p; j++) x_norm = x_norm + x(j,0)*x(j,0);
  x_norm = sqrt(x_norm);
  return(x_norm);
}

// Soft-thresholding operator
// [[Rcpp::export]]
double S(double z, double l) {
  if (z > l) return(z-l);
  if (z < -l) return(z+l);
  return(0);
}

// Firm-thresholding operator
// [[Rcpp::export]]
double F(double z, double l1, double l2, double gamma) {
  double s=0;
  if (z > 0) s = 1;
  else if (z < 0) s = -1;
  if (fabs(z) <= l1) return(0);
  else if (fabs(z) <= gamma*l1*(1+l2)) return(s*(fabs(z)-l1)/(1+l2-1/gamma));
  else return(z/(1+l2));
}

// SCAD-modified firm-thresholding operator
// [[Rcpp::export]]
double Fs(double z, double l1, double l2, double gamma) {
  double s=0;
  if (z > 0) s = 1;
  else if (z < 0) s = -1;
  if (fabs(z) <= l1) return(0);
  else if (fabs(z) <= (l1*(1+l2)+l1)) return(s*(fabs(z)-l1)/(1+l2));
  else if (fabs(z) <= gamma*l1*(1+l2)) return(s*(fabs(z)-gamma*l1/(gamma-1))/(1-1/(gamma-1)+l2));
  else return(z/(1+l2));
}

// [[Rcpp::export]]
Eigen::MatrixXd p_CSH_OH(Eigen::MatrixXd eta,int k,int J, int K){
  Eigen::MatrixXd lamb(J+1,1);
  lamb.setZero(J+1,1);
  double temp=1;
  for(int j = 0 ; j<J ; j++){
    lamb(j,0)=exp(eta(k+j*K,0));
    temp += lamb(j,0);
  }
  lamb=lamb/(temp);
  lamb(J,0)=(temp-1)/(temp);
  return lamb;
}

// [[Rcpp::export]]
double maxgrad(Eigen::MatrixXd X, Eigen::MatrixXd T, Eigen::MatrixXd r, Eigen::MatrixXd K1, Eigen::MatrixXd m, double J, double G, double N, double K, double P) {
  
  // Declarations
  double zmax=0;
  double z_norm=0;
  double shift=0;
  double temp=0;
  
  for (int j=0; j<J; j++){
    for (int g=0; g<G; g++) {
      // Calculate z
      int Kg = K1(g+1,0) - K1(g,0);
      Eigen::MatrixXd z(Kg,1);
      z.setZero(Kg,1);
      for (int kg=K1(g,0); kg<K1(g+1,0); kg++) {
        shift = 0;
        temp = 0;
        for(int i = 0 ; i<N ; i++){
          for (int k=0; k<=(T(i,0)-1); k++){
            shift += X(i,kg)*r(i,k+K*j);
            temp ++;
          }
        }
        z(kg-K1(g,0),0) = shift/temp;
      }
      z_norm = norm(z,Kg)/m(g,0);//need to write norm function
      Rcout<<z_norm;
      Rcout<<"\n";
      if(z_norm>zmax) zmax=z_norm;
    }
  }
  return(zmax);
}


// [[Rcpp::export]]
List GD_CR_MM_intercept(Eigen::MatrixXd T, Eigen::MatrixXd ind, Eigen::MatrixXd X, Eigen::MatrixXd K1, double K0, Eigen::MatrixXd lambda,Eigen::MatrixXd m, double alpha, double eps, int max_iter, double gamma, int dfmax, int gmax, int warn, int user, int penalty){
  int N = X.rows();
  int P = X.cols();
  int J = ind.maxCoeff();
  int K = T.maxCoeff();
  int L = lambda.rows();
  int G = K1.rows() - 1;
  
  // Outcome
  List result;
  Eigen::MatrixXd beta0(K*J,L);
  beta0.setZero(K*J,L);
  Eigen::MatrixXd beta(P*J,L);
  beta.setZero(P*J,L);
  Eigen::MatrixXd iter(L,1);
  iter.setZero(L,1);
  Eigen::MatrixXd df(L,1);
  df.setZero(L,1);
  Eigen::MatrixXd Dev(L,1);
  Dev.setZero(L,1);
  int tot_iter = 0;
  Eigen::MatrixXd b0 = beta0;
  Eigen::MatrixXd b = beta;
  
  // Intermediate quantities
  Eigen::MatrixXd a0(K*J,1); // Beta0 from previous iteration
  a0.setZero(K*J,1);
  Eigen::MatrixXd r(N,K*J);
  r.setZero(N,K*J);
  Eigen::MatrixXd eta(N,K*J);
  eta.setZero(N,K*J);
  Eigen::MatrixXd a(P*J,1);
  a.setZero(P*J,1);
  Eigen::MatrixXd e(G*J,1);
  e.setZero(G*J,1);
  Eigen::MatrixXd OH(K,1); //overall hazard
  OH.setZero(K,1);
  Eigen::MatrixXd mu(J+1,1);
  mu.setZero(J+1,1);
  int lstart=0, ng=0, nv=0, violations=0;
  double shift=0, l1=0, l2=0, v=0, si=0, maxChange=0, z_norm=0, len=0;
  int temp=0; //temp be the count
  
  // Initialization
  Eigen::MatrixXd ybar(K*J,1);
  ybar.setZero(K*J,1); //ybar is the average cause specific hazard
  for (int k = 0 ; k<K ; k++){
    temp=0;
    for(int i = 0 ; i<N ; i++){
      if(T(i,0)>=(k+1)){
        temp++;
      }
      for(int j = 0 ; j<J ; j++){
        if(T(i,0)==(k+1) and ind(i,0)==(j+1)){
          ybar(k+j*K,0)++;
        }
      }
    }
    for(int j = 0 ; j<J ; j++){
      ybar(k+j*K,0)=ybar(k+j*K,0)/temp;
      OH(k,0)=OH(k,0)+ybar(k+j*K,0);
    }
    for(int j = 0 ; j<J ; j++){
      a0(k+j*K,0)=log(ybar(k+j*K,0)/(1-OH(k,0)));
      b0(k+j*K,0)=a0(k+j*K,0);
    }
  }
  

  v = 0.25; //second derivative approximation, MM algorithm, second derivative is vector so the computing speed is not reduced very much
  maxChange=0;
  for (int j=0; j<J; j++){
    for (int i=0; i<N; i++){
      for (int k=0; k<(T(i,0)-1); k++){
        mu = p_CSH_OH(eta.block(i,0,1,K*J).transpose(),k,J,K);//cause specific hazard([0 to (J-1)],0) and overall hazard(J,0)
        r(i,k+K*j) = (0 - mu(j,0))/v ; //Z-eta

      }
      mu = p_CSH_OH(eta.block(i,0,1,K*J).transpose(),(T(i,0)-1),J,K);
      if(ind(i,0)==(j+1)){
        r(i,(T(i,0)-1)+K*j) = (1 - mu(j,0))/v ;

      }
      else{
        r(i,(T(i,0)-1)+K*j) = (0 - mu(j,0))/v ;
      }
    }
  }
  
  result["residual"]=r;
  return(result);
  
}


// [[Rcpp::export]]
List GD_CR_MM(double omg,Eigen::MatrixXd Beta_v, Eigen::MatrixXd Beta_t ,Eigen::MatrixXd T, Eigen::MatrixXd ind, Eigen::MatrixXd X, Eigen::MatrixXd K1, double K0, Eigen::MatrixXd lambda,Eigen::MatrixXd m, double alpha, double eps, int max_iter, double gamma, int dfmax, int gmax, int warn, int user, int penalty){
  // Lengths/dimensions
  int N = X.rows();
  int P = X.cols();
  int J = ind.maxCoeff();
  int K = T.maxCoeff();
  int L = lambda.rows();
  int G = K1.rows() - 1;
  
  // Outcome
  List result;
  Eigen::MatrixXd beta0(K*J,L);
  beta0.setZero(K*J,L);
  Eigen::MatrixXd beta(P*J,L);
  beta.setZero(P*J,L);
  Eigen::MatrixXd iter(L,1);
  iter.setZero(L,1);
  Eigen::MatrixXd df(L,1);
  df.setZero(L,1);
  Eigen::MatrixXd Dev(L,1);
  Dev.setZero(L,1);
  int tot_iter = 0;
  Eigen::MatrixXd b0 = beta0;
  Eigen::MatrixXd b = beta;

  // Intermediate quantities
  Eigen::MatrixXd a0(K*J,1); // Beta0 from previous iteration
  a0.setZero(K*J,1);
  Eigen::MatrixXd r(N,K*J);
  r.setZero(N,K*J);
  Eigen::MatrixXd eta(N,K*J);
  eta.setZero(N,K*J);
  Eigen::MatrixXd lam_p(N,K*(J+1));
  lam_p.setZero(N,K*(J+1));
  Eigen::MatrixXd eta_p(N,K*J);
  eta_p.setZero(N,K*J);
  Eigen::MatrixXd a(P*J,1);
  a.setZero(P*J,1);
  Eigen::MatrixXd e(G*J,1);
  e.setZero(G*J,1);
  Eigen::MatrixXd OH(K,1); //overall hazard
  OH.setZero(K,1);
  Eigen::MatrixXd mu(J+1,1);
  mu.setZero(J+1,1);
  Eigen::MatrixXd tmp1(1,1);
  tmp1.setZero(1,1);
  int lstart=0, ng=0, nv=0, violations=0;
  double shift=0, l1=0, l2=0, v=0, si=0, maxChange=0, z_norm=0, len=0;
  int temp=0; //temp be the count
  
  // Initialization
  
  //calculate prior
  for(int i = 0 ; i<N ; i++){
    for(int j = 0 ; j<J ; j++){
      tmp1=(X.block(i,0,1,P)*Beta_v.block(0,j,P,1));
      for (int k = 0 ; k<K ; k++){
        eta_p(i,k+j*K)=Beta_t(k,j)+tmp1(0,0);
      }
    }
  }
  
  for(int i = 0 ; i<N ; i++){
    for (int k = 0 ; k<K ; k++){
      mu=p_CSH_OH(eta_p.block(i,0,1,K*J).transpose(),k,J,K);
      for(int j = 0 ; j<=J ; j++){
        lam_p(i,k+j*K)=mu(j,0);
      }
    }
  }
  
  /*result["lam_p"]=lam_p;
  result["eta_p"]=eta_p;
  return(result);*/
  
  //calculate
  Eigen::MatrixXd ybar(K*J,1);
  ybar.setZero(K*J,1); //ybar is the average cause specific hazard
  for (int k = 0 ; k<K ; k++){
    temp=0;
    for(int i = 0 ; i<N ; i++){
      if(T(i,0)>=(k+1)){
        temp++;
        for(int j = 0 ; j<J ; j++){
          ybar(k+j*K,0)+=omg*lam_p(i,k+j*K);
        }
      }
      for(int j = 0 ; j<J ; j++){
        if(T(i,0)==(k+1) and ind(i,0)==(j+1)){
          ybar(k+j*K,0)++;
        }
      }
    }
    for(int j = 0 ; j<J ; j++){
      ybar(k+j*K,0)=ybar(k+j*K,0)/temp/(1+omg);
      OH(k,0)=OH(k,0)+ybar(k+j*K,0);
    }
    for(int j = 0 ; j<J ; j++){
      a0(k+j*K,0)=log(ybar(k+j*K,0)/(1-OH(k,0)));
      b0(k+j*K,0)=a0(k+j*K,0);
    }
  }
  double nullDev = 0;
  for (int i=0; i<N; i++){
    for (int k=0; k<(T(i,0)-1); k++){
      nullDev -= 2*log((1-OH(k,0)));
    }
    if(ind(i,0)==0){
      nullDev -= 2*log((1-OH(T(i,0)-1,0)));
    }
    else{
      nullDev -= 2*log(ybar((T(i,0)-1)+(ind(i,0)-1)*K,0));
    }
  }
  
  
  for (int i=0; i<N; i++){
    eta.block(i,0,1,J*K)=a0.transpose();
  }
  
  Rcout<<ybar;
  Rcout<<"\n******\n";
  Rcout<<a0;
  Rcout<<"\n******\n";
  Rcout<<OH;
  Rcout<<"\n******\n";
  Rcout<<omg;
  
  // If lam[0]=lam_max, skip lam[0] -- closed form sol'n available
  if (user) {
    lstart = 0;
  } else {
    lstart = 1;
    Dev(0,0) = nullDev;
  }
  
  /*
  result["N"]=N;
  result["P"]=P;
  result["J"]=J;
  result["a0"]=a0;
  result["OH"]=OH;
  result["ybar"]=ybar;
  return(result);*/
  
  // Path
  for (int l=lstart; l<L; l++){
    Rcout<<"\n";
    Rcout<<l;
    R_CheckUserInterrupt();
    if (l != 0) {
      a0 = b0.block(0,l-1,J*K,1);
      a=b.block(0,l-1,P*J,1);
      
      // Check dfmax, gmax
      // predecide how many groups or parameters we want to select
      ng = 0;
      nv = 0;
      for (int j=0; j<J; j++){
        for (int g=0; g<G; g++) {
          if (a(K1(g,0)+j*P,0) != 0) {
            ng++;
            nv = nv + (K1(g+1,0)-K1(g,0));
          }
        }
      }
      if (ng > gmax || nv > dfmax || tot_iter == max_iter) {
        for (int ll=l; ll<L; ll++) iter(ll,0) = NA_INTEGER;
        Rcout<<"\nbreak through gmax and dfmax\n";
        Rcout<<ng;
        Rcout<<"\n";
        Rcout<<nv;
        Rcout<<"\n";
        Rcout<<gmax;
        Rcout<<"\n";
        Rcout<<dfmax;
        Rcout<<"\n";
        Rcout<<tot_iter;
        Rcout<<"\n";
        Rcout<<max_iter;
        break;
      }
    }
    
    while (tot_iter < max_iter) {
      while (tot_iter < max_iter) { //Two loop add up to max_iter, can be problematic, because its combined together, inner loop can go to far
        iter(l,0)++;
        tot_iter++;
        
        // Approximate L
        Dev(l,0) = 0;
        v = 0.25; //second derivative approximation, MM algorithm, second derivative is vector so the computing speed is not reduced very much
        maxChange=0;
        df(l,0)=K*J+K0*J;
        for (int j=0; j<J; j++){
          for (int i=0; i<N; i++){
            for (int k=0; k<(T(i,0)-1); k++){
              mu = p_CSH_OH(eta.block(i,0,1,K*J).transpose(),k,J,K);//cause specific hazard([0 to (J-1)],0) and overall hazard(J,0)
              r(i,k+K*j) = (((0+omg*lam_p(i,k+j*K))/(1+omg)) - mu(j,0)) / v; //Z-eta
              Dev(l,0) -= 2*log((1-mu(J,0)));
            }
            mu = p_CSH_OH(eta.block(i,0,1,K*J).transpose(),(T(i,0)-1),J,K);
            if(ind(i,0)==(j+1)){
              r(i,(T(i,0)-1)+K*j) = (((1+omg*lam_p(i,(T(i,0)-1)+j*K))/(1+omg)) - mu(j,0)) / v;
              Dev(l,0) -= 2*log((mu(j,0)));
            }
            else{
              r(i,(T(i,0)-1)+K*j) = (((0+omg*lam_p(i,(T(i,0)-1)+j*K))/(1+omg)) - mu(j,0)) / v;
              if(ind(i,0)==0){
                Dev(l,0) -= 2*log((1-mu(J,0)));
              }
              else{
                Dev(l,0) -= 2*log((mu((ind(i,0)-1),0)));
              }
            }
          }
          
          // Update intercept
          for (int k = 0 ; k<K ; k++){
            temp=0;
            shift=0;
            for(int i = 0 ; i<N ; i++){
              if(T(i,0)>=(k+1)){
                temp++;
                shift+=r(i,k+K*j);
              }
            }
            shift=shift/temp;
            b0(k+K*j,l)=shift+a0(k+K*j,0);
            for (int i=0; i<N; i++){
              r(i,k+K*j) -= shift;
              eta(i,k+K*j) += shift;
            }
          }
          
          if (fabs(shift) > maxChange) maxChange = fabs(shift);
          
          // Update unpenalized covariates
          
          for (int k0=0; k0<K0; k0++){
            shift = 0;
            temp = 0;
            for(int i = 0 ; i<N ; i++){
              for (int k=0; k<=(T(i,0)-1); k++){
                shift += X(i,k0)*r(i,k+K*j);
                temp ++;
              }
            }
            shift = shift/temp;
            if (fabs(shift) > maxChange) maxChange = fabs(shift);
            b(k0+j*P,l) = shift + a(k0+j*P,0);
            for (int i=0; i<N; i++){
              si = shift * X(i,k0);
              for (int k=0; k<=(T(i,0)-1); k++){
                r(i,k+K*j) -= si;
                eta(i,k+K*j) += si;
              }
            }
          }
          
          // Update penalized groups
          for (int g=0; g<G; g++) {
            l1 = lambda(l,0) * m(g,0) * alpha;
            l2 = lambda(l,0) * m(g,0) * (1-alpha);
            if(e(g+j*G,0)==1){
              // Calculate z
              int Kg = K1(g+1,0) - K1(g,0);
              Eigen::MatrixXd z(Kg,1);
              z.setZero(Kg,1);
              for (int kg=K1(g,0); kg<K1(g+1,0); kg++) {
                shift = 0;
                temp = 0;
                for(int i = 0 ; i<N ; i++){
                  for (int k=0; k<=(T(i,0)-1); k++){
                    shift += X(i,kg)*r(i,k+K*j);
                    temp ++;
                  }
                }
                z(kg-K1(g,0),0) = shift/temp + a(kg+j*P,0);
              }
              z_norm = norm(z,Kg);//need to write norm function
              if (penalty==1) len = S(v * z_norm, l1) / (v * (1 + l2));//Lasso
              if (penalty==2) len = F(v * z_norm, l1, l2, gamma) / v;//MCP
              if (penalty==3) len = Fs(v * z_norm, l1, l2, gamma) / v;//SCAD
              if (len != 0 || a(K1(g,0)+j*P,0) != 0) {// a[K1[g]]!=0, len = 0, it will panelize g to be 0
                // If necessary, update b and r
                for (int kg=K1(g,0); kg<K1(g+1,0); kg++) {
                  b(kg+j*P,l) = len * z(kg-K1(g,0),0) / z_norm;
                  double shift = b(kg+j*P,l)-a(kg+j*P,0);
                  if (fabs(shift) > maxChange) maxChange = fabs(shift);
                  for (int i=0; i<N; i++){
                    si = shift * X(i,kg);
                    for (int k=0; k<=(T(i,0)-1); k++){
                      r(i,k+K*j) -= si;
                      eta(i,k+K*j) += si;
                    }
                  }
                }
              }
              
              // Update df
              if (len > 0) df(l,0) += Kg * len / z_norm;
            }
          }//end of update penalized groups
          
        }//end of J loop
        
        // Check convergence
        a0 = b0.block(0,l,J*K,1);
        a=b.block(0,l,P*J,1);
        if (maxChange < eps) break;
        
        // Check for saturation
        if (Dev(l,0)/nullDev < .01) {//early stopping? print(REAL(Dev)[l]/nullDev)
          if (warn) warning("Model saturated; exiting...");
          for (int ll=l; ll<L; ll++) iter(ll,0) = NA_INTEGER;// might need to change this indicator
          tot_iter = max_iter;
          break;//need to respecify to make sure it break through all the loops
        }
      }//end of second while loop
      
      // Scan for violations
      violations = 0;
      
      for (int j=0; j<J; j++){
        for (int g=0; g<G; g++) {
          if (e(g+j*G,0)==0) {
            l1 = lambda(l,0) * m(g,0) * alpha;
            l2 = lambda(l,0) * m(g,0) * (1-alpha);
            
            // Calculate z
            int Kg = K1(g+1,0) - K1(g,0);
            Eigen::MatrixXd z(Kg,1);
            z.setZero(Kg,1);
            for (int kg=K1(g,0); kg<K1(g+1,0); kg++) {
              shift = 0;
              temp = 0;
              for(int i = 0 ; i<N ; i++){
                for (int k=0; k<=(T(i,0)-1); k++){
                  shift += X(i,kg)*r(i,k+K*j);
                  temp ++;
                }
              }
              z(kg-K1(g,0),0) = shift/temp + a(kg+j*P,0);
            }
            z_norm = norm(z,Kg);//need to write norm function
            if (penalty==1) len = S(v * z_norm, l1) / (v * (1 + l2));
            if (penalty==2) len = F(v * z_norm, l1, l2, gamma) / v;
            if (penalty==3) len = Fs(v * z_norm, l1, l2, gamma) / v;
            
            if (len != 0 || a(K1(g,0)+j*P,0) != 0) {// a[K1[g]]!=0, len = 0, it will panelize g to be 0
              // If necessary, update b and r
              for (int kg=K1(g,0); kg<K1(g+1,0); kg++) {
                b(kg+j*P,l) = len * z(kg-K1(g,0),0) / z_norm;
                double shift = b(kg+j*P,l)-a(kg+j*P,0);
                if (fabs(shift) > maxChange) maxChange = fabs(shift);
                for (int i=0; i<N; i++){
                  si = shift * X(i,kg);
                  for (int k=0; k<=(T(i,0)-1); k++){
                    r(i,k+K*j) -= si;
                    eta(i,k+K*j) += si;
                  }
                }
              }
            }
            // Update df
            if (len > 0) df(l,0) += Kg * len / z_norm;
            
            if (b(K1(g,0)+j*P,l) != 0) {
              e(g+j*G,0) = 1;
              violations++;
            }
          }
        }
      }
      
      if (violations==0) break;
      a0 = b0.block(0,l,J*K,1);
      a=b.block(0,l,P*J,1);
      
      
    }//end of first while loop
    
  }// end of L loop
  
  result["Betat"]=b0;
  result["Betav"]=b;
  result["iter"]=iter;
  result["df"]=df;
  result["Dev"]=Dev;
  result["eta"]=eta;
  result["residual"]=r;
  return(result);
  
}