library(Rcpp)
library(matrixStats)
library(survival)
library(Rcpp)
library(bench)
library(tidyr)
library(discSurv)
library(expm)
library(coxed)
library(mvtnorm)
library(bench)
library(nnet)

dataLong <- function (dataSet, timeColumn, censColumn, timeAsFactor=TRUE,
                      remLastInt=FALSE, aggTimeFormat=FALSE, lastTheoInt=NULL) {
  
  # Input checks
  if(!is.data.frame(dataSet)) {stop("Argument *dataSet* is not in the correct format! Please specify as data.frame object.")}
  if(!(is.character(timeColumn))) {stop("Argument *timeColumn* is not in the correct format! Please specify as character.")}
  if(length(timeColumn)!=1) {stop("Argument *timeColumn* is not in the correct format! Please specify as scalar with length one.")}
  if(!(is.character(censColumn))) {stop("Argument *censColumn* is not in the correct format! Please specify as character.")}
  if(length(censColumn)!=1) {stop("Argument *censColumn* is not in the correct format! Please specify as scalar with length one.")}
  
  # Can *timeColumn* be accessed in *dataSet*?
  if(any(class(tryCatch(dataSet [, timeColumn], error=function (e) e)) == "error")) {
    stop("*timeColumn* is not available in *dataSet*! Please specify the correct column of observed times.")
  }
  
  # Can *censColumn* be accessed in *dataSet*?
  if(any(class(tryCatch(dataSet [, censColumn], error=function (e) e)) == "error")) {
    stop("*censColumn* is not available in *dataSet*! Please specify the correct column of the event indicator.")
  }
  
  # Check if observed times are only integer values
  if(!all(dataSet [, timeColumn]==floor(as.numeric(as.character(dataSet [, timeColumn]))))) {
    stop("*timeColumn* has not only integer values! Please convert the observed time in discrete intervals.")
  }
  
  # Check if event indicator has only zero or one values
  #if(!all(as.numeric(as.character(dataSet [, censColumn]))==0 | as.numeric(as.character(dataSet [, censColumn]))==1)) {
  #stop("*censColumn* is not a binary vector! Please check, that events equals 1 and 0 otherwise.")
  #}
  
  ##################
  # Main Code
  
  # Extract column index of survival and censoring times
  c1 <- which(eval(timeColumn)==colnames(dataSet))
  c2 <- which(eval(censColumn)==colnames(dataSet))
  
  # Construct indices of persons
  if(aggTimeFormat){
    obj <- rep(1:nrow(dataSet), each=lastTheoInt)
  } else{
    obj <- rep(1:nrow(dataSet), as.vector(dataSet[, c1]))
  }
  
  # Long format of covariates
  dataSetLong <- dataSet[obj, ]
  
  # Calculate discrete time interval
  if(aggTimeFormat){
    if(timeAsFactor) {
      timeInt <- factor( rep(1:lastTheoInt, nrow(dataSet)) )
    }
    else{
      timeInt <- rep(1:lastTheoInt, nrow(dataSet))
    }
    # Calculate response
    y <- c(unlist(apply(dataSet, 1, FUN = 
                          function(k) c(rep(0, as.numeric(k[c1])-1), as.numeric(k[c2]), 
                                        rep(0, lastTheoInt - as.numeric(k[c1]) ) ) )))
    
  } else{
    if(timeAsFactor) {
      timeInt <- factor(unlist(apply(dataSet, 1, FUN = function(k) 1:k[c1])))
    }
    else{
      timeInt <- unlist(apply(dataSet, 1, FUN = function(k) 1:k[c1]))
    }
    # Calculate response
    y <- c(unlist(apply(dataSet, 1, FUN = 
                          function(k) c(rep(0, as.numeric(k[c1])-1), as.numeric(k[c2])) )))
  }
  
  # Aggregate results in one data.frame
  dataSetLong <- cbind(obj, timeInt, y, dataSetLong)
  
  if(remLastInt) {
    # Remove cases with observed values in last interval, 
    # because the hazard is always 1
    # t==t_max & event==1 -> t==t_max-1 & event==0
    remInd <- which(dataSetLong$y==1 & 
                      dataSetLong$timeInt==max(as.numeric(as.character(
                        dataSetLong$timeInt))) )
    if(length(remInd)!=0) {
      dataSetLong <- dataSetLong[-remInd, ]
    }
  }
  
  return(dataSetLong)
} 


X_gen=function(cov,x){
  chol_cov=chol(cov)
  return (x%*%chol_cov)
}

Cov=function(r,c,min,max){
  x=runif(r*c,min,max)
  dim(x)=c(r,c)
  return(x)
}

#AR1 correlation matrix
AR1 <- function(tau, m) {
  if(m==1) {R <- 1}
  if(m > 1) {
    R <- diag(1, m)
    for(i in 1:(m-1)) {
      for(j in (i+1):m) {
        R[i,j] <- R[j,i] <- tau^(abs(i-j))
      }
    }
  }
  return(R)
}


X_sim=function(r,c,group,min,max,tau){
  x=rnorm(r*c)
  dim(x)=c(r,c)
  covm=rep(0,c*c)
  dim(covm)=c(c,c)
  ng=length(group)
  for (i in 1:(ng-1)){
    ind=(group[i]+1):group[i+1]
    covm[ind,ind]=AR1(tau,group[i+1]-group[i])
    if(i!=(ng-1)){
      for (j in (i+1):(ng-1)) {
        ind2=(group[j]+1):group[j+1]
        cov_inter=Cov(group[i+1]-group[i],group[j+1]-group[j],min,max)
        covm[ind,ind2]=cov_inter
        covm[ind2,ind]=t(cov_inter)
      }
    }
    
  }
  return(X_gen(covm,x))
  
}

prob_n=function(x,betat,betav,r,c,mt,nr,unif=TRUE){
  t=rep(0,r*(nr+1))
  dim(t)=c(r,nr+1)
  denom=rep(1,r*mt)
  dim(denom)=c(r,mt)
  for (k in 1:nr){
    xb=x%*%betav[,k]
    xbm=rep(xb,mt)
    dim(xbm)=c(r,mt)
    bt=rep(betat[,k], each=r)
    dim(bt)=c(r,mt)
    denom=denom+exp(bt+xbm)
  }
  for (k in 1:nr){
    xb=x%*%betav[,k]
    xbm=rep(xb,mt)
    dim(xbm)=c(r,mt)
    bt=rep(betat[,k], each=r)
    dim(bt)=c(r,mt)
    Fm=exp(bt+xbm)/denom
    Fm_1=1-Fm
    for(i in 1:r){
      for (j in 1:mt){
        temp=sample(c(0,1),1,replace = T, prob = c((1-Fm[i,j]),Fm[i,j]))
        if(temp==1){
          t[i,k]=j
          break
        }
        else if(j==mt){
          t[i,k]=mt+1
        }
      }
    }
  }
  if(unif){
    for(i in 1:r){t[i,nr+1]=sample(1:mt,1)}
  }
  else{
    xb=x%*%betav[,nr+1]
    xbm=rep(xb,mt)
    dim(xbm)=c(r,mt)
    bt=rep(betat[,nr+1], each=r)
    dim(bt)=c(r,mt)
    Fm=1/(1+exp(-bt-xbm))
    Fm_1=1-Fm
    for(i in 1:r){
      for (j in 1:mt){
        temp=sample(c(0,1),1,replace = T, prob = c((1-Fm[i,j]),Fm[i,j]))
        if(temp==1){
          t[i,nr+1]=j
          break
        }
        else if(j==mt){
          t[i,nr+1]=mt
        }
      }
    }
  }
  
  return(t)
}

kl_lik <- function(eta, X,prior_y,y,c,alp=1,nfold=5){
  eta_vec <- eta
  X <- as.data.frame(X)
  likelihood <- eta_vec - eta_vec
  obj=unique(X$obj)
  folds <- cut(seq(1,length(obj)),breaks=nfold,labels=FALSE)
  k = 0
  for (eta in eta_vec){
    print(eta)
    k = k+1
    likelihood_cv = rep(0, nfold)
    for (cv in 1:nfold){
      obj_test=obj[which(folds==cv,arr.ind=TRUE)]
      obj_train=obj[-which(folds==cv,arr.ind=TRUE)]
      X_test=X[X$obj%in%obj_test, ]
      X_train=X[X$obj%in%obj_train, ]
      Y_train=(y[X$obj%in%obj_train, ]+prior_y[X$obj%in%obj_train, ]*eta)/(1+eta)
      Y_test=y[X$obj%in%obj_test, ]
      model=multinom(formula = Y_train ~ . -1, data = X_train[,c(2,(1:c)+3)],trace=F)
      pred=predict(model,X_test[,c(2,(1:c)+3)],"prob")
      likelihood_cv[cv] <- -2*sum(Y_test*log(pred))
    }
    likelihood[k] <- mean(likelihood_cv)
    print(likelihood[k])
    print("\n")
  }
  min_loc <- which(likelihood==min(likelihood))
  eta_where_min <- eta_vec[min_loc][1]
  return_list <- list("eta"= eta_where_min, "likelihood"=likelihood,"eta_vec"=eta_vec)
  return(return_list)
}

sim=function(N,Betat,Betav,c=4,r1=10000,r2=1000,r3=5000,mt=10,nr=2,eta_set=(0:100)/10,tau=0.5){
  
  dev_p=c()
  dev_l=c()
  dev_KL=c()
  dev_OKL=c()
  dev_OFKL=c()
  dev_j=c()
  eta_vec=c()
  eta_OKL_vec=c()
  eta_OFKL_vec=c()
  
  for(i in 1:N){
    #external data generation
    x=rmvnorm(r1,mean = c(0,0,0,0),sigma = diag(c(1,1,1,1)))
    t_mat=prob_n(x,Betat,Betav,r1,c,mt,nr,unif = T)
    ind=apply(t_mat,1,which.min)
    ind[ind==3]=0
    t=apply(t_mat,1,min)
    
    #external model fitting
    X_p=as.data.frame(cbind(x,t,ind))
    Z_p=dataLong(X_p,"t","ind")
    y_p=rep(0,(nr+1)*nrow(Z_p))
    dim(y_p)=c(nrow(Z_p),nr+1)
    for(i in 1:nrow(Z_p)){
      y_p[i,Z_p$y[i]+1]=1
    }
    model_prior=multinom(formula = y_p ~ . -1, data = Z_p[,c(2,(1:c)+3)],trace=F)
    
    #local data generation
    x=rmvnorm(r2,mean = c(0,0,0,0),sigma = diag(c(1,1,1,1)))
    t_mat=prob_n(x,Betat,Betav,r2,c,mt,nr,unif = T)
    ind=apply(t_mat,1,which.min)
    ind[ind==3]=0
    t=apply(t_mat,1,min)
    
    #local model fitting
    X_l=as.data.frame(cbind(x,t,ind))
    Z_l=dataLong(X_l,"t","ind")
    y_l=rep(0,(nr+1)*nrow(Z_l))
    dim(y_l)=c(nrow(Z_l),nr+1)
    for(i in 1:nrow(Z_l)){
      y_l[i,Z_l$y[i]+1]=1
    }
    model_local=multinom(formula = y_l ~ . -1, data = Z_l[,c(2,(1:c)+3)],trace=F)
    
    #prior prediction of local
    prior_y=predict(model_prior,Z_l[,c(2,(1:c)+3)],"prob")
    
    #select eta
    eta_select=kl_lik(eta=eta_set, X=Z_l,prior_y=prior_y,y=y_l,c,alp=1,nfold=5)
    eta=eta_select$eta
    
    print("CKL Eta done")
    
    y_KL=(y_l+eta*prior_y)/(1+eta)
    
    model_KL=multinom(formula = y_KL ~ . -1, data = Z_l[,c(2,(1:c)+3)],trace=F)
    
    print("CKL done")
    
    ##OKL
    Oprior_y=prior_y
    temp=1
    for(j in 2:nrow(Oprior_y)){
      if(temp!=floor(as.numeric(rownames(Oprior_y)[j]))){
        temp=floor(as.numeric(rownames(Oprior_y)[j]))
      }
      else{
        Oprior_y[j,]=Oprior_y[j,]*Oprior_y[j-1,1]
      }
    }
    
    #select eta
    eta_select_OKL=kl_lik(eta=eta_set, X=Z_l,prior_y=Oprior_y,y=y_l,c,alp=1,nfold=5)
    eta_OKL=eta_select_OKL$eta
    
    print("OKL Eta done")
    
    y_OKL=(y_l+eta_OKL*Oprior_y)/(1+eta_OKL)
    
    model_OKL=multinom(formula = y_OKL ~ . -1, data = Z_l[,c(2,(1:c)+3)],trace=F)
    
    print("OKL done")
    
    '##full-length
    ##OFKL
    t=rep(mt,r2)
    XF_l=as.data.frame(cbind(x,t,ind))
    ZF_l=dataLong(XF_l,"t","ind")
    OFprior_y=predict(model_prior,ZF_l[,c(2,(1:c)+3)],"prob")
    OFlocal_y=predict(model_local,ZF_l[,c(2,(1:c)+3)],"prob")
    temp=1
    for(j in 2:nrow(OFprior_y)){
      if(temp!=floor(as.numeric(rownames(OFprior_y)[j]))){
        temp=floor(as.numeric(rownames(OFprior_y)[j]))
      }
      else{
        OFprior_y[j,]=OFprior_y[j,]*OFprior_y[j-1,1]
      }
    }
    
    temp=1
    for(j in 2:nrow(OFlocal_y)){
      if(temp!=floor(as.numeric(rownames(OFlocal_y)[j]))){
        temp=floor(as.numeric(rownames(OFlocal_y)[j]))
      }
      else{
        OFlocal_y[j,]=OFlocal_y[j,]*OFlocal_y[j-1,1]
      }
    }
    
    #select eta
    eta_select_OFKL=kl_lik(eta=eta_set, X=ZF_l,prior_y=OFprior_y,y=OFlocal_y,c,alp=1,nfold=5)
    eta_OFKL=eta_select_OFKL$eta
    
    print("OFKL Eta done")
    
    y_OFKL=(OFlocal_y+eta_OFKL*OFprior_y)/(1+eta_OFKL)
    
    model_OFKL=multinom(formula = y_OFKL ~ . -1, data = ZF_l[,c(2,(1:c)+3)],trace=F)
    
    print("OFKL done")'
    
    Z_j=rbind(Z_p,Z_l)
    y_j=rbind(y_p,y_l)
    model_joint=multinom(formula = y_j ~ . -1, data = Z_j[,c(2,(1:c)+3)],trace=F)
    
    print("joint done")
    
    #generate test data
    x=rmvnorm(r3,mean = c(0,0,0,0),sigma = diag(c(1,1,1,1)))
    t_mat=prob_n(x,Betat,Betav,r3,c,mt,nr,unif = T)
    ind=apply(t_mat,1,which.min)
    ind[ind==3]=0
    t=apply(t_mat,1,min)
    
    #test data expansion
    X_t=as.data.frame(cbind(x,t,ind))
    Z_t=dataLong(X_t,"t","ind")
    y_t=rep(0,(nr+1)*nrow(Z_t))
    dim(y_t)=c(nrow(Z_t),nr+1)
    for(i in 1:nrow(Z_t)){
      y_t[i,Z_t$y[i]+1]=1
    }
    
    print("test done")
    
    pred_p=predict(model_prior,Z_t[,c(2,(1:c)+3)],"prob")
    pred_l=predict(model_local,Z_t[,c(2,(1:c)+3)],"prob")
    pred_KL=predict(model_KL,Z_t[,c(2,(1:c)+3)],"prob")
    pred_OKL=predict(model_OKL,Z_t[,c(2,(1:c)+3)],"prob")
    #pred_OFKL=predict(model_OFKL,Z_t[,c(2,(1:c)+3)],"prob")
    pred_j=predict(model_joint,Z_t[,c(2,(1:c)+3)],"prob")
    
    dev_p=c(dev_p,-2*sum(y_t*log(pred_p)))
    dev_l=c(dev_l,-2*sum(y_t*log(pred_l)))
    dev_KL=c(dev_KL,-2*sum(y_t*log(pred_KL)))
    dev_OKL=c(dev_OKL,-2*sum(y_t*log(pred_OKL)))
    #dev_OFKL=c(dev_OFKL,-2*sum(y_t*log(pred_OFKL)))
    dev_j=c(dev_j,-2*sum(y_t*log(pred_j)))
    eta_vec=c(eta_vec,eta)
    eta_OKL_vec=c(eta_OKL_vec,eta_OKL)
    #eta_OFKL_vec=c(eta_OFKL_vec,eta_OFKL)
    
  }
  
  return(cbind(dev_p,dev_l,dev_KL,dev_OKL,dev_j,eta_vec,eta_OKL_vec))
}

multiX <- function(X, m) {
  p <- ncol(X)
  n <- nrow(X)
  A <- matrix(0, m*n, m*p)
  for (i in 1:m) {
    A[m*(1:n)-i+1, m*(1:p)-i+1] <- X
  }
  cbind(matrix(as.double(diag(m)), m*n, m, byrow=TRUE)[,2:m], A)
}
multiG <- function(g, ncolY) {
  structure(c(rep(0, ncolY-1), rep(g, each=ncolY)),
            levels=attr(g, 'levels'),
            m=attr(g, 'm'))
}

orthogonalize <- function(X, group) {
  n <- nrow(X)
  J <- max(group)
  T <- vector("list", J)
  XX <- matrix(0, nrow=nrow(X), ncol=ncol(X))
  XX[, which(group==0)] <- X[, which(group==0)]
  for (j in seq_along(integer(J))) {
    ind <- which(group==j)
    if (length(ind)==0) next
    SVD <- svd(X[, ind, drop=FALSE], nu=0)
    r <- which(SVD$d > 1e-10)
    T[[j]] <- sweep(SVD$v[, r, drop=FALSE], 2, sqrt(n)/SVD$d[r], "*")
    XX[, ind[r]] <- X[, ind] %*% T[[j]]
  }
  nz <- !apply(XX==0, 2, all)
  XX <- XX[, nz, drop=FALSE]
  attr(XX, "T") <- T
  attr(XX, "group") <- group[nz]
  XX
}

unorthogonalize <- function(b, XX, group, intercept=TRUE) {
  ind <- !sapply(attr(XX, "T"), is.null)
  T <- bdiag(attr(XX, "T")[ind])
  if (intercept) {
    ind0 <- c(1, 1+which(group==0))
    val <- Matrix::as.matrix(rbind(b[ind0, , drop=FALSE], T %*% b[-ind0, , drop=FALSE]))
  } else if (sum(group==0)) {
    ind0 <- which(group==0)
    val <- Matrix::as.matrix(rbind(b[ind0, , drop=FALSE], T %*% b[-ind0, , drop=FALSE]))
  } else {
    val <- as.matrix(T %*% b)
  }
}

unstandardize <- function(b, XG) {
  beta <- matrix(0, nrow=1+length(XG$scale), ncol=ncol(b))
  beta[1 + XG$nz,] <- b[-1,] / XG$scale[XG$nz]
  beta[1,] <- b[1,] - crossprod(XG$center, beta[-1, , drop=FALSE])
  beta
}

setupG <- function(group, m, bilevel) {
  gf <- factor(group)
  if (any(levels(gf)=='0')) {
    g <- as.integer(gf) - 1
    lev <- levels(gf)[levels(gf)!='0']
  } else {
    g <- as.integer(gf)
    lev <- levels(gf)
  }
  if (is.numeric(group) | is.integer(group)) {
    lev <- paste0("G", lev)
  }
  if (missing(m)) {
    m <- rep(NA, length(lev))
    names(m) <- lev
  } else {
    #if (all.equal(sort(names(m)), sort(group)))
    TRY <- try(as.integer(group)==g)
    if (inherits(TRY, 'try-error') || any(!TRY)) stop('Attempting to set group.multiplier is ambiguous if group is not a factor', call.=FALSE)
    if (length(m) != length(lev)) stop("Length of group.multiplier must equal number of penalized groups", call.=FALSE)
    if (storage.mode(m) != "double") storage.mode(m) <- "double"
    if (any(m < 0)) stop('group.multiplier cannot be negative', call.=FALSE)
  }
  structure(g, levels=lev, m=m)
}

subsetG <- function(g, nz) {
  lev <- attr(g, 'levels')
  m <- attr(g, 'm')
  new <- g[nz]
  dropped <- setdiff(g, new)
  if (length(dropped)) {
    lev <- lev[-dropped]
    m <- m[-dropped]
    gf <- factor(new)
    new <- as.integer(gf) - 1*any(levels(gf)=='0')
  }
  structure(new, levels=lev, m=m)
}
reorderG <- function(g, m, bilevel) {
  og <- g
  lev <- attr(g, 'levels')
  m <- attr(g, 'm')
  if (any(g==0)) {
    g <- as.integer(relevel(factor(g), "0"))-1
  }
  if (any(order(g) != 1:length(g))) {
    reorder <- TRUE
    gf <- factor(g)
    if (any(levels(gf)=="0")) {
      gf <- relevel(gf, "0")
      g <- as.integer(gf) - 1
    } else {
      g <- as.integer(gf)
    }
    ord <- order(g)
    ord.inv <- match(1:length(g), ord)
    g <- g[ord]
  } else {
    reorder <- FALSE
    ord <- ord.inv <- NULL
  }
  structure(g, levels=lev, m=m, ord=ord, ord.inv=ord.inv, reorder=reorder)
}


newXG <- function(X, g, m, ncolY, bilevel) {
  # Coerce X to matrix
  if (!inherits(X, "matrix")) {
    tmp <- try(X <- model.matrix(~0+., data=X), silent=TRUE)
    if (inherits(tmp, "try-error")) stop("X must be a matrix or able to be coerced to a matrix", call.=FALSE)
  }
  if (storage.mode(X)=="integer") storage.mode(X) <- "double"
  if (any(is.na(X))) stop("Missing data (NA's) detected in X.  You must eliminate missing data (e.g., by removing cases, removing features, or imputation) before passing X to grpreg", call.=FALSE)
  if (length(g) != ncol(X)) stop ("Dimensions of group is not compatible with X", call.=FALSE)
  xnames <- if (is.null(colnames(X))) paste("V", 1:ncol(X), sep="") else colnames(X)
  
  # Setup group
  G <- setupG(g, m, bilevel)
  
  # Reconfigure for multiple outcomes, if necessary
  if (ncolY > 1) {
    X <- multiX(X, ncolY)
    G <- multiG(G, ncolY)
  }
  
  # Feature-level standardization
  std <- .Call("standardize", X)
  XX <- std[[1]]
  center <- std[[2]]
  scale <- std[[3]]
  nz <- which(scale > 1e-6)                # non-constant columns
  if (length(nz) != ncol(X)) {
    XX <- XX[, nz, drop=FALSE]
    G <- subsetG(G, nz)
  }
  
  # Reorder groups, if necessary
  G <- reorderG(G, attr(G, 'm'), bilevel)
  if (attr(G, 'reorder')) XX <- XX[, attr(G, 'ord')]
  
  # Group-level standardization
  if (!bilevel) {
    XX <- orthogonalize(XX, G)# how to transform back to the original scale
    g <- attr(XX, "group")
  } else {
    g <- as.integer(G)
  }
  
  # Set group multiplier if missing
  m <- attr(G, 'm')
  if (all(is.na(m))) {
    m <- if (bilevel) rep(1, max(g)) else sqrt(table(g[g!=0]))
  }
  
  # Return
  return(list(X=XX, g=g, m=m, reorder=attr(G, 'reorder'), ord.inv=attr(G, 'ord.inv'), names=xnames,
              center=center, scale=scale, nz=nz))
}

setupG <- function(group, m, bilevel) {
  gf <- factor(group)
  if (any(levels(gf)=='0')) {
    g <- as.integer(gf) - 1
    lev <- levels(gf)[levels(gf)!='0']
  } else {
    g <- as.integer(gf)
    lev <- levels(gf)
  }
  if (is.numeric(group) | is.integer(group)) {
    lev <- paste0("G", lev)
  }
  if (missing(m)) {
    m <- rep(NA, length(lev))
    names(m) <- lev
  } else {
    #if (all.equal(sort(names(m)), sort(group)))
    TRY <- try(as.integer(group)==g)
    if (inherits(TRY, 'try-error') || any(!TRY)) stop('Attempting to set group.multiplier is ambiguous if group is not a factor', call.=FALSE)
    if (length(m) != length(lev)) stop("Length of group.multiplier must equal number of penalized groups", call.=FALSE)
    if (storage.mode(m) != "double") storage.mode(m) <- "double"
    if (any(m < 0)) stop('group.multiplier cannot be negative', call.=FALSE)
  }
  structure(g, levels=lev, m=m)
}

newY <- function(y, family) {
  if (is.data.frame(y)) y <- as.matrix(y)
  if (is.matrix(y)) {
    d <- dim(y)
    y <- t(y)
  } else {
    d <- c(length(y), 1)
  }
  
  # Convert fuzzy binomial data
  if (family=="binomial" && typeof(y) != "logical") {
    tab <- table(y)
    if(!as.logical(prod(0<=y)*prod(1>=y))){
      print("caution")
      if (length(tab) > 2) stop("Attemping to use family='binomial' with non-binary data", call.=FALSE)
      if (!identical(names(tab), c("0", "1"))) {
        message(paste0("Logistic regression modeling Pr(y=", names(tab)[2], ")"))
        y <- as.double(as.character(y) == names(tab)[2])
        if (d[2] > 1) attr(y, "dim") <- d
      }
    }
    
  }
  
  # Convert to double, if necessary
  if (typeof(y) != "double") {
    tryCatch(storage.mode(y) <- "double", warning=function(w) {stop("y must be numeric or able to be coerced to numeric", call.=FALSE)})
  }
  if (any(is.na(y))) stop("Missing data (NA's) detected in outcome y.  You must eliminate missing data (e.g., by removing cases or imputation) before passing y to grpreg", call.=FALSE)
  
  # Handle multi
  if (is.matrix(y)) {
    if (ncol(y) > 1) {
      if (is.null(colnames(y))) paste("Y", 1:ncol(y), sep="")
    }
    attributes(y) <- NULL
  }
  
  if (family=="gaussian") {
    meanY <- mean(y)
    y <- y - meanY
    attr(y, "mean") <- meanY
  }
  attr(y, "m") <- d[2]
  y
}



setwd("~/Desktop/research/Kevin He/Competing_risk_KL/simulation/")
sourceCpp("../C_code/LASSO_MM_CR.cpp")
dyn.load("../C_code/my.so")

#Start Simulation

r=10000
c=4
mt=10
nr=2
x_p=rmvnorm(r,mean = rep(0,100),sigma = diag(rep(1,100)))

#betav=cbind(c(-0.5,0,0,0),c(0,0,0,0),c(0,0,0,0))
#betat=cbind(c(-5+(1:mt)*3/mt),c(-5+(1:mt)*3/mt),rep(0,mt))

betav=cbind(c(-0.05,-0.2,0.05,0.2,rep(0,96)),c(-0.15,0.1,0.15,-0.1,rep(0,96)),rep(0,c))
#betat=cbind(c(-0.02,-0.02,-0.02,-0.2,-0.2,-0.2,-0.2,-0.2,-0.2,-0.2),c(-0.02,-0.04,-0.06,-0.10,-0.17,-0.11,-0.13,-0.15,-0.18,-0.22),rep(0,mt))
#betat=cbind(c(-3,-2.9,-2.77,-2.64,-2.48,-2.3,-2.08,-1.8,-1.38,-0.7),c(-3,-2.9,-2.77,-2.64,-2.48,-2.3,-2.08,-1.8,-1.38,-0.7),rep(0,mt))
betat=cbind(c(-2.3,-2.2,-2.08,-1.95,-1.8,-1.61,-1.39,-1.1,-0.7,-0),c(-2.3,-2.2,-2.08,-1.95,-1.8,-1.61,-1.39,-1.1,-0.7,-0),rep(0,mt))
t_mat_p=prob_n(x_p,betat,betav,r,c,mt,nr,unif = T)
ind_p=apply(t_mat_p,1,which.min)
ind_p[ind_p==3]=0
t_p=apply(t_mat_p,1,min)

lamb=exp(seq(from=log(0.025),to=log(0.00001),length.out = 100))
XG <- newXG(x_p, 1:ncol(x_p), rep(1,ncol(x_p)), 1, FALSE)
n <- nrow(XG$X)
p <- ncol(XG$X)
K <- as.integer(table(XG$g))
K0 <- as.integer(if (min(XG$g)==0) K[1] else 0)
K1 <- as.integer(if (min(XG$g)==0) cumsum(K) else c(0, cumsum(K)))
model_prior=GD_CR_MM(omg=0,Beta_v = cbind(rep(0,100),rep(0,100)),Beta_t = cbind(rep(0,10),rep(0,10)),t(t(t_p)), t(t(ind_p)), XG$X, t(t(K1)), t(t(K0)), lambda=t(t(lamb)), m=t(t(rep(1,ncol(x_p)))), alpha=1, eps=0.000000001, max_iter=100000, gamma=3.5, dfmax=2*ncol(x_p), gmax=2*ncol(x_p), warn=T, user=1, penalty=1)

par(mar = c(5, 5, 2, 2))
plot(1,type = "n",ylim = c(-0.25,0.25),xlim = c(1,100),xlab = "Iteration",ylab = "Coefficients",cex.lab=2,cex.axis=2)
for (i in 5:100) {
  lines(1:100,model_prior$Betav[i,],ty="l",col="Grey",lty=2)
}
for (i in 105:200) {
  lines(1:100,model_prior$Betav[i,],ty="l",col="Grey",lty=2)
}
lines(1:100,model_prior$Betav[1,],ty="l",col="red")
lines(1:100,model_prior$Betav[2,],ty="l",col="red")
lines(1:100,model_prior$Betav[3,],ty="l",col="red")
lines(1:100,model_prior$Betav[4,],ty="l",col="red")
lines(1:100,model_prior$Betav[101,],ty="l",col="green")
lines(1:100,model_prior$Betav[102,],ty="l",col="green")
lines(1:100,model_prior$Betav[103,],ty="l",col="green")
lines(1:100,model_prior$Betav[104,],ty="l",col="green")

r=1000
c=4
mt=10
nr=2
x_l=rmvnorm(r,mean = rep(0,100),sigma = diag(rep(1,100)))

#betav=cbind(c(-0.5,0,0,0),c(0,0,0,0),c(0,0,0,0))
#betat=cbind(c(-5+(1:mt)*3/mt),c(-5+(1:mt)*3/mt),rep(0,mt))

betav=cbind(c(-0.05,-0.2,0.05,0.2,rep(0,96)),c(-0.15,0.1,0.15,-0.1,rep(0,96)),rep(0,c))
#betat=cbind(c(-0.02,-0.02,-0.02,-0.2,-0.2,-0.2,-0.2,-0.2,-0.2,-0.2),c(-0.02,-0.04,-0.06,-0.10,-0.17,-0.11,-0.13,-0.15,-0.18,-0.22),rep(0,mt))
#betat=cbind(c(-3,-2.9,-2.77,-2.64,-2.48,-2.3,-2.08,-1.8,-1.38,-0.7),c(-3,-2.9,-2.77,-2.64,-2.48,-2.3,-2.08,-1.8,-1.38,-0.7),rep(0,mt))
betat=cbind(c(-2.3,-2.2,-2.08,-1.95,-1.8,-1.61,-1.39,-1.1,-0.7,-0),c(-2.3,-2.2,-2.08,-1.95,-1.8,-1.61,-1.39,-1.1,-0.7,-0),rep(0,mt))
t_mat_l=prob_n(x_l,betat,betav,r,c,mt,nr,unif = T)
ind_l=apply(t_mat_l,1,which.min)
ind_l[ind_l==3]=0
t_l=apply(t_mat_l,1,min)

lamb=exp(seq(from=log(0.025),to=log(0.00001),length.out = 100))
XG <- newXG(x_l, 1:ncol(x_l), rep(1,ncol(x_l)), 1, FALSE)
n <- nrow(XG$X)
p <- ncol(XG$X)
K <- as.integer(table(XG$g))
K0 <- as.integer(if (min(XG$g)==0) K[1] else 0)
K1 <- as.integer(if (min(XG$g)==0) cumsum(K) else c(0, cumsum(K)))
model_local=GD_CR_MM(omg=0,Beta_v = cbind(rep(0,100),rep(0,100)),Beta_t = cbind(rep(0,10),rep(0,10)),t(t(t_l)), t(t(ind_l)), XG$X, t(t(K1)), t(t(K0)), lambda=t(t(lamb)), m=t(t(rep(1,ncol(x_l)))), alpha=1, eps=0.000000001, max_iter=100000, gamma=3.5, dfmax=2*ncol(x_l), gmax=2*ncol(x_l), warn=T, user=1, penalty=1)

par(mar = c(5, 5, 2, 2))
plot(1,type = "n",ylim = c(-0.25,0.25),xlim = c(1,100),xlab = "Iteration",ylab = "Coefficients",cex.lab=2,cex.axis=2)
for (i in 5:100) {
  lines(1:100,model_local$Betav[i,],ty="l",col="Grey",lty=2)
}
for (i in 105:200) {
  lines(1:100,model_local$Betav[i,],ty="l",col="Grey",lty=2)
}
lines(1:100,model_local$Betav[1,],ty="l",col="red")
lines(1:100,model_local$Betav[2,],ty="l",col="red")
lines(1:100,model_local$Betav[3,],ty="l",col="red")
lines(1:100,model_local$Betav[4,],ty="l",col="red")
lines(1:100,model_local$Betav[101,],ty="l",col="green")
lines(1:100,model_local$Betav[102,],ty="l",col="green")
lines(1:100,model_local$Betav[103,],ty="l",col="green")
lines(1:100,model_local$Betav[104,],ty="l",col="green")

model_KL=GD_CR_MM(omg=3,Beta_v = cbind(model_prior$Betav[1:100,40],model_prior$Betav[101:200,40]),Beta_t = cbind(model_prior$Betat[1:10,40],model_prior$Betat[11:20,40]),t(t(t_l)), t(t(ind_l)), XG$X, t(t(K1)), t(t(K0)), lambda=t(t(lamb)), m=t(t(rep(1,ncol(x_l)))), alpha=1, eps=0.000000001, max_iter=100000, gamma=3.5, dfmax=2*ncol(x_l), gmax=2*ncol(x_l), warn=T, user=1, penalty=1)

par(mar = c(5, 5, 2, 2))
plot(1,type = "n",ylim = c(-0.25,0.25),xlim = c(1,100),xlab = "Iteration",ylab = "Coefficients",cex.lab=2,cex.axis=2)
for (i in 5:100) {
  lines(1:100,model_KL$Betav[i,],ty="l",col="Grey",lty=2)
}
for (i in 105:200) {
  lines(1:100,model_KL$Betav[i,],ty="l",col="Grey",lty=2)
}
lines(1:100,model_KL$Betav[1,],ty="l",col="red")
lines(1:100,model_KL$Betav[2,],ty="l",col="red")
lines(1:100,model_KL$Betav[3,],ty="l",col="red")
lines(1:100,model_KL$Betav[4,],ty="l",col="red")
lines(1:100,model_KL$Betav[101,],ty="l",col="green")
lines(1:100,model_KL$Betav[102,],ty="l",col="green")
lines(1:100,model_KL$Betav[103,],ty="l",col="green")
lines(1:100,model_KL$Betav[104,],ty="l",col="green")

ind_j=c(ind_p,ind_l)
t_j=c(t_p,t_l)
x_j=rbind(x_p,x_l)

lamb=exp(seq(from=log(0.025),to=log(0.00001),length.out = 100))
XG <- newXG(x_j, 1:ncol(x_j), rep(1,ncol(x_j)), 1, FALSE)
n <- nrow(XG$X)
p <- ncol(XG$X)
K <- as.integer(table(XG$g))
K0 <- as.integer(if (min(XG$g)==0) K[1] else 0)
K1 <- as.integer(if (min(XG$g)==0) cumsum(K) else c(0, cumsum(K)))
model_joint=GD_CR_MM(omg=0,Beta_v = cbind(model_prior$Betav[1:100,40],model_prior$Betav[101:200,40]),Beta_t = cbind(model_prior$Betat[1:10,40],model_prior$Betat[11:20,40]),t(t(c(t_j))), t(t(c(ind_j))), XG$X, t(t(K1)), t(t(K0)), lambda=t(t(lamb)), m=t(t(rep(1,ncol(x_j)))), alpha=1, eps=0.000000001, max_iter=100000, gamma=3.5, dfmax=2*ncol(x_j), gmax=2*ncol(x_j), warn=T, user=1, penalty=1)

par(mar = c(5, 5, 2, 2))
plot(1,type = "n",ylim = c(-0.25,0.25),xlim = c(1,100),xlab = "Iteration",ylab = "Coefficients",cex.lab=2,cex.axis=2)
for (i in 5:100) {
  lines(1:100,model_joint$Betav[i,],ty="l",col="Grey",lty=2)
}
for (i in 105:200) {
  lines(1:100,model_joint$Betav[i,],ty="l",col="Grey",lty=2)
}
lines(1:100,model_joint$Betav[1,],ty="l",col="red")
lines(1:100,model_joint$Betav[2,],ty="l",col="red")
lines(1:100,model_joint$Betav[3,],ty="l",col="red")
lines(1:100,model_joint$Betav[4,],ty="l",col="red")
lines(1:100,model_joint$Betav[101,],ty="l",col="green")
lines(1:100,model_joint$Betav[102,],ty="l",col="green")
lines(1:100,model_joint$Betav[103,],ty="l",col="green")
lines(1:100,model_joint$Betav[104,],ty="l",col="green")                