% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BRIGHTs.R
\name{BRIGHTs}
\alias{BRIGHTs}
\title{BRIGHT estimation procedure for summary level data}
\usage{
BRIGHTs(
  data,
  m = NA,
  group = NA,
  penalty = 1,
  tau = 1/3,
  eta = c(0, exp(seq(log(0.1), log(10), length.out = 20))),
  lambda = NA,
  nlambda = 100,
  lambda.min = 0.001,
  alpha = 1,
  gamma = 0,
  eps = 1e-07,
  max_iter = 1e+06,
  dfmax = 5000,
  gmax = 5000,
  user = T
)
}
\arguments{
\item{data}{a list of preprocessed data from \code{PreprocessS()}. For details please refer to the \code{PreprocessS()} section.}

\item{m}{a numeric verticle vector of the multiplicative factor to adjust for the number of SNPs in each group, the default is the square root of number of elements in each group.}

\item{group}{a vector describing the grouping of the coefficients. For greatest efficiency and least ambiguity (see details), it is best if group is a factor or vector of consecutive integers, although unordered groups and character vectors are also allowed. If there are coefficients to be included in the model without being penalized, assign them to group 0 (or "0").}

\item{penalty}{a integer scalar for chosing the penalties; 1 corresponds to elastic net (with alpha=0 to be LASSO); 2 corresponds to MCP; 3 corresponds to SCAD.}

\item{tau}{tuning parameter for the group exponential lasso; defaults to 1/3.}

\item{eta}{a numeric scalar of the weights for incorporating prior information.}

\item{lambda}{a numeric verticle vector of the LASSO penalty weights; it must be sorted with a decreasing order.}

\item{alpha}{\code{BRIGHT} allows for both a group penalty and an L2 (ridge)
penalty; \code{alpha} controls the proportional weight of the regularization
parameters of these two penalties.  The group penalties' regularization
parameter is \code{lambda*alpha}, while the regularization parameter of the
ridge penalty is \code{lambda*(1-alpha)}.  Default is 1: no ridge penalty.}

\item{gamma}{tuning parameter of the group or composite MCP/SCAD penalty
(see details).  Default is 3 for MCP and 4 for SCAD.}

\item{eps}{convergence threshhold.  The algorithm iterates until the RMSD
for the change in linear predictors for each coefficient is less than
\code{eps}.  Default is \code{1e-4}.  See details.}

\item{dfmax}{limit on the number of parameters allowed to be nonzero.  If
this limit is exceeded, the algorithm will exit early from the
regularization path.}

\item{gmax}{limit on the number of groups allowed to have nonzero elements.
If this limit is exceeded, the algorithm will exit early from the
regularization path.}

\item{user}{a logical scalar for indicating whether lambda is user specified; if user=TRUE, then the iteration will start from the largest lambda, otherwise the iteration will start from the second largest lambda.}

\item{max.iter}{maximum number of iterations (total across entire path).
Default is 10000.  See details.}
}
\value{
Write a list of results containing: beta, the coefficient estimate from BRIGHT;

iter, the number of total iterations needed for the model to converge with each lambda;

df total degree of freedom of the converged model with each lambda;

dev, the approximated deviance associated with each lambda.
}
\description{
Fit BRIGHT estimation procedure for summary level data (BRIGHTs) with grouped penalties (LASSO, elastic net, MCP, SCAD) over a grid of values of the regularization parameter lambda and the prior data weight eta.
}
\details{
For more information about the penalties and their properties, please
consult the references below, many of which contain discussion, case
studies, and simulation studies comparing the methods.  If you use
\code{BRIGHT} for an analysis, please cite the appropriate reference.

In keeping with the notation from the original MCP paper, the tuning
parameter of the MCP penalty is denoted 'gamma'.  Note, however, that in
Breheny and Huang (2009), \code{gamma} is denoted 'a'.

The objective function for \code{BRIGHTs} optimization is defined to be
\deqn{Q(\beta)=r\beta+\beta\Sigma\beta/2+(\beta'-\beta)\Sigma(\beta'-\beta)/2+p(\beta),}  where the first two terms on the right hand side (RHS) are
a approximation of the OLS loss; the second term on the RHS is the Bregman-divergence; the third term on the RHS is the penalty.

The algorithms employed by \code{BRIGHT} are stable and generally converge
quite rapidly to values close to the solution.  However, especially when p
is large compared with n, \code{BRIGHT} may fail to converge at low values
of \code{lambda}, where models are nonidentifiable or nearly singular.
Often, this is not the region of the coefficient path that is most
interesting.  The default behavior warning the user when convergence
criteria are not met may be distracting in these cases, and can be modified
with \code{warn} (convergence can always be checked later by inspecting the
value of \code{iter}).

If models are not converging, increasing \code{max.iter} may not be the most
efficient way to correct this problem.  Consider increasing \code{n.lambda}
or \code{lambda.min} in addition to increasing \code{max.iter}.

Although \code{BRIGHT} allows groups to be unordered and given arbitary
names, it is recommended that you specify groups as consecutive integers.
The first reason is efficiency: if groups are out of order, \code{X} must be
reordered prior to fitting, then this process reversed to return
coefficients according to the original order of \code{X}.  This is
inefficient if \code{X} is very large.  The second reason is ambiguity with
respect to other arguments such as \code{group.multiplier}.  With
consecutive integers, \code{group=3} unambiguously denotes the third element
of \code{group.multiplier}.

\code{BRIGHT} requires groups to be non-overlapping.
}
