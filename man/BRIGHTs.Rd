% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BRIGHT.R
\name{BRIGHTs}
\alias{BRIGHTs}
\title{BRIGHT estimation procedure for summary level data}
\usage{
BRIGHTs(
  XtY,
  Beta_prior,
  X,
  lambda,
  K1,
  m,
  blk,
  K0,
  penalty = 1,
  tau = 0,
  eta,
  alpha = 1,
  gamma = 0,
  eps = 1e-07,
  max_iter = 1e+06,
  dfmax = 5000,
  gmax = 5000,
  user = T
)
}
\arguments{
\item{XtY}{a numeric verticle vector of the marginal correlation between genotype and outcome, can be recovered from GWAS summary statistics by function p2cor().}

\item{Beta_prior}{a numeric verticle vector of the prior information; in the case where prior information is a subspace of XtY, set the complement set to be zero.}

\item{X}{a numeric matrix of reference genotypes, default is from 1000 genome project.}

\item{lambda}{a numeric verticle vector of the LASSO penalty weights; it must be sorted with a decreasing order.}

\item{K1}{a numeric verticle vector of the grouping of SNPs for group penalties; SNPs within K1[i,i+1] are grouped together.}

\item{m}{a numeric verticle vector of the multiplicative factor to adjust for the number of SNPs in each group, the default is the square root of number of elements in each group.}

\item{blk}{a numeric verticle vector indicating the grouping of SNPs in each block, can be generated through LD() function.}

\item{K0}{a integer scalar for the number of SNPs/covariates that is not penalized.}

\item{penalty}{a integer scalar for chosing the penalties; 1 corresponds to LASSO, 2 corresponds to MCP, 3 corresponds to SCAD.}

\item{tau}{tuning parameter for the group exponential lasso; defaults to
1/3.}

\item{eta}{a numeric scalar of the weights for incorporating prior information.}

\item{alpha}{\code{grpreg} allows for both a group penalty and an L2 (ridge)
penalty; \code{alpha} controls the proportional weight of the regularization
parameters of these two penalties.  The group penalties' regularization
parameter is \code{lambda*alpha}, while the regularization parameter of the
ridge penalty is \code{lambda*(1-alpha)}.  Default is 1: no ridge penalty.}

\item{gamma}{tuning parameter of the group or composite MCP/SCAD penalty
(see details).  Default is 3 for MCP and 4 for SCAD.}

\item{eps}{convergence threshhold.  The algorithm iterates until the RMSD
for the change in linear predictors for each coefficient is less than
\code{eps}.  Default is \code{1e-4}.  See details.}

\item{dfmax}{limit on the number of parameters allowed to be nonzero.  If
this limit is exceeded, the algorithm will exit early from the
regularization path.}

\item{gmax}{limit on the number of groups allowed to have nonzero elements.
If this limit is exceeded, the algorithm will exit early from the
regularization path.}

\item{user}{a logical scalar for indicating whether lambda is user specified; if user=TRUE, then the iteration will start from the largest lambda, otherwise the iteration will start from the second largest lambda.}

\item{max.iter}{maximum number of iterations (total across entire path).
Default is 10000.  See details.}
}
\value{
Write a list of results containing: beta, the coefficient estimate from BRIGHT;

iter, the number of total iterations needed for the model to converge with each lambda;

df total degree of freedom of the converged model with each lambda;

dev, the approximated deviance associated with each lambda.
}
\description{
Fit BRIGHT estimation procedure for summary level data with grouped penalties over a grid of values of the regularization parameter lambda.
}
\details{
For more information about the penalties and their properties, please
consult the references below, many of which contain discussion, case
studies, and simulation studies comparing the methods.  If you use
\code{BRIGHT} for an analysis, please cite the appropriate reference.

In keeping with the notation from the original MCP paper, the tuning
parameter of the MCP penalty is denoted 'gamma'.  Note, however, that in
Breheny and Huang (2009), \code{gamma} is denoted 'a'.

The objective function for \code{BRIGHTi} optimization is defined to be
\deqn{Q(\beta)=r\beta+\beta\Sigma\beta/2+(\beta'-\beta)\Sigma(\beta'-\beta)/2n+p(\beta),}  where the first two terms on the right hand side (RHS) are
a approximation of the OLS loss; the second term on the RHS is the Bregman-divergence; the third term on the RHS is the penalty.

The algorithms employed by \code{BRIGHT} are stable and generally converge
quite rapidly to values close to the solution.  However, especially when p
is large compared with n, \code{BRIGHT} may fail to converge at low values
of \code{lambda}, where models are nonidentifiable or nearly singular.
Often, this is not the region of the coefficient path that is most
interesting.  The default behavior warning the user when convergence
criteria are not met may be distracting in these cases, and can be modified
with \code{warn} (convergence can always be checked later by inspecting the
value of \code{iter}).

If models are not converging, increasing \code{max.iter} may not be the most
efficient way to correct this problem.  Consider increasing \code{n.lambda}
or \code{lambda.min} in addition to increasing \code{max.iter}.

Although \code{BRIGHT} allows groups to be unordered and given arbitary
names, it is recommended that you specify groups as consecutive integers.
The first reason is efficiency: if groups are out of order, \code{X} must be
reordered prior to fitting, then this process reversed to return
coefficients according to the original order of \code{X}.  This is
inefficient if \code{X} is very large.  The second reason is ambiguity with
respect to other arguments such as \code{group.multiplier}.  With
consecutive integers, \code{group=3} unambiguously denotes the third element
of \code{group.multiplier}.

\code{BRIGHT} requires groups to be non-overlapping.
}
